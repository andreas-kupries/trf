% -*- latex -*-
\documentclass {report}
\usepackage    {makeidx}
\usepackage    {html}
\include       {defs}
\makeindex

% external, but distributed here too
\def\install{	\htmladdnormallink {install.tex}	 {../install/install.html}}
\def\installman{\htmladdnormallink {installation manual} {../install/install.html}}
\def\capi{      \htmladdnormallink {C-level} {../capi/capi.html}}
\def\capiref{   \htmladdnormallink {online reference} {../capi/capi.html}}
\def\manps{     \htmladdnormallink{postscript version}{man.ps.gz}}
\def\strterm{$\backslash 0$}

% remove this for the official release.
%\def\unoff{
%	\strong{Beware:} This is an unofficial and unannounced
%	release, just to have a complete web site. The official
%	distribution will be made as soon as tcl 8.0b1 is out. Because
%	of this no binary release for \win{} was made, too.}


\begin {document}

\title{The \trf {} (transformer) extension to Tcl}
\author{Andreas Kupries \\ Aachen}
\date{\today}
\maketitle 

\begin{htmlonly}
\begin{center}\large
	This document accompanies \trf{} @mFullVersion@, as
	distributed at @mDate@.
\end{center}

A \manps{} is available.
\index{postscript version}
% much more indexing is required!

\strong{Warning:} The contents of this document are likely to change.
It is advisable not to use links to any pages other than the first
page (this page).
\end{htmlonly}

\begin{abstract} 
\trf {} is an extension library to the script language \tcl, as created
by \jo. It extends the language at the C-level with so-called
``transformer''-procedures. With the help of some patches to the core
the package is able to intercept all read/write operations on
designated channels, thus giving it the ability to transform the
buffer contents as desired. This allows things like transparent
encryption, compression, charset recoding, etc.
Build upon this framework (and as proof of concept) a collection of
\tcl{}-level commands was implemented, most of them related to
cryptography. Additionally some binary data support is put in as well.
\end{abstract} 
\pagebreak
\tableofcontents

\chapter {Introduction}
This is the reference manual of Tcl-Trf @mFullVersion@, as distributed
at @mDate@. For instructions on how to compile and install it see
\file {\install} or one of its derivatives (\file {install.dvi},
\html{\htmladdnormallink{install.ps}{install.ps.gz}}
\latex{\file{install.ps}}).

%\unoff

After torturing the world with 2 extensions related to binary support
in tcl (\blob{} and \blobx{}) I could not resist and wrote another
one :-). It can be seen as a merger of features from these 2, but in
contrast to them it is build on top of the binary data support coming
in tcl8.0, aka

\begin{itemize}
\item	the \cmd{binio} command,
\item	memory channels,
\item	and transformation procedures.
\end{itemize}

\strong {This is not true in the current implementation}. Please read
the \installman{} to gain insight into the requirements of this
extension.

At the \capi{} a set of commands is provided for management,
implementation and usage of ``transformer''-procedures. These are
called by the (patched) generic channel system to pre- or postprocess
data just before writing, resp. immediately after reading. This allows
transparent implementation of things like:

\begin {itemize}
\item	Gathering statistics about the data flowing through a channel.
% This I had in the first implementation, should port it to this one too.

\item	Converting in and out of printable representations of binary
	data.
\item	Decryption, encryption of information read or written.
\item	Data de(compression), error correcting coding.
\end   {itemize}
to name only a few.

As proof of concept several such algorithms were implemented and are
provided as user-commands at the \tcl{}-level. As most of them are
related to cryptography in one way or naother, this library might be
seen as cryptographic toolkit too.


\chapter {Where to get}

This library is available at
\begin {itemize}
\item[] Primary urls:
\begin {itemize}
\item[Sources:] \url {ftp://ftp.westend.com/pub/aku/trf@mFullVersion@.tar.gz} (~800 K)
\item[Same, different archiver:] \url {ftp://ftp.westend.com/pub/aku/trf@mDosVersion@.zip} (~1 M)
\item[Short documentation:] \url {ftp://ftp.westend.com/pub/aku/trf@mFullVersion@.README} (~2 K)
\item[Windows binary distribution:] \url {ftp://ftp.westend.com/pub/aku/trf@mShortDosVersion@bin.zip} (~260 K)
\end {itemize}

\item[] Secondary urls:
\begin {itemize}
\item \url {ftp://ftp.kisters.de/pub/lang/tcl/ext/trf@mFullVersion@.tar.gz}
\item \url {ftp://ftp.kisters.de/pub/lang/tcl/ext/trf@mDosVersion@.zip}
\item \url {ftp://ftp.kisters.de/pub/lang/tcl/ext/trf@mFullVersion@.readme}
\item \url {ftp://ftp.westend.com/pub/aku/trf@mShortDosVersion@bin.zip}
\end {itemize}
\end {itemize}


\chapter {Acknowledgements}

\begin {itemize}\Large
\item	Guess who ? \jo{} for \tcl {} itself. 
\item	\jyl
\item	\bast{} for general friendship.
\item	\greyham{} for \cmd {c2man}.
\item	\jan{} for support, encouragement
	(transformation procedures as part of his plus-patches) and
	several patches enhancing the usability (load-on-demand of
	libz, \dots{}) of this package.
\end   {itemize}

Neither the encryption algorithms nor the message digests were
implemented by myself, they are all from other persons. See chapter
\ref {copyright} for more information.


\chapter {Danger ahead}

First some remarks regarding the work with binary data (and this
package) in general:

\begin {enumerate}
\item	Whatever you do, don't forget to switch the used channels into
	binary mode, i.e. execute ``fconfigure <channel> -translation
	binary''. Not doing this will produce all kind of strange
	errors, even on unix machines, as the default translation mode
	(``auto'') will not only convert CR LF into LF, but a single
	CR as well!

\item	Using transformation procedures (as in this package)
	introduces an additional level of buffering because they are
	permitted to buffer all characters they are unable to process
	immediately. This may mess up especially
	interprocess communication, a notoriously problematic field. A
	not so improbable scenario would be the addition of encryption
	to enhance security. Using a blockcipher here may lead to the
	following problem (a line-oriented protocol is assumed):

	\begin {itemize}
	\item	The sender produces a line and writes it into the channel,
		waiting for a response from the receiver afterward.
	\item	The channel system invokes the blockcipher to encrypt
		the line, but not all characters are encrypted due to
		the length of the line not being a multiple of the
		blocksize. Especially the EOL-character is neither
		encrypted, nor transmitted.
	\item	The receiver decrypts the blocks it got, then waits
		for the EOL character.
	\item	\strong {DEADLOCK}.
	\end   {itemize}

	The solution here would be the usage of a blockcipher in CFB
	mode and shift $=$ 1 or that of a stream cipher, as both of these
	would encrypt single characters without buffering.

	Data compression is another good candidate for such a situation.

	Because of this I decided to include the number of characters
	buffered by a certain transformation in its description.

\end   {enumerate}


\chapter {The available commands}

First a small note: This manual deals with the \tcl{}-level commands
only. For a description of the C-level API please read the
manpages\html{ or the \capiref{}}.


All commands are available in 2 modes of operation, ``immediate'' and
``attached''. The generic syntactical forms of these modes are:

\begin {itemize}
\item[immediate:]	\cmd {command} -option arg {value} \dots{} \arg {source} \arg {destination}

	In this mode the command reads data from the channel \arg
	{source}, transforms it according to its specification (and
	the configuration as defined by the options) and then writes
	the result into the \arg {destination} channel. 

\item[attached:]	\cmd {command} -attach \arg {channel} -option \arg {value} \dots{}

	Here a transformation procedure is created, configured as
	defined by the options and then attached to the \arg
	{channel}. All data read from or written into the \arg
	{channel} will be transformed accordingly from now on. 

	This mode is the one requiring the patches to the
	core. Without them we would be unable to stack our
	transformational channel onto the named one.
\end   {itemize}


\section {Encryption}

The ciphers implemented here are

\begin {enumerate}
\item	DES 	(the dinosaur)
\item	IDEA	(used by \PGP)
\item	Blowfish
\item	RC2
\item	RC4
\end   {enumerate}

The commands to invoke them are identical to the names, converted to
all lowercase. Options common to them all:

\begin {itemize}
\item [-direction]	Allowed values are ``encrypt'', ``decrypt'' and all
			unique abbreviations. Specifies the operation
			to be executed in immediate mode or the
			operation executed upon \strong {write} if
			attached to a channel.

\item [-key]		Argument to this option has to be a readable
			channel. The user key for encryption and/or
			decryption is defined by the contents of this
			channel. The minimum and maximum number of
			bytes to be read are cipher dependent and will
			be described later.
\end   {itemize}

The first 4 ciphers are blockciphers, i.e. they do not encrypt single
characters, but blocks of 2 or more. Such ciphers can be operated in 4
different modes and therefore have additional options defined:

\begin {itemize}
\item[-mode]	The 4 possible argument values (and modes) are:
	\begin {itemize}
	\item[ecb]	$=$ \strong {e}lectronic \strong {c}ode\strong {b}ook.
	\item[cbc]	$=$ \strong {c}ipher \strong{b}lock \strong{c}haining.
	\item[cfb]	$=$ \strong {c}ipher \strong {f}eed\strong {b}ack.
	\item[ofb]	$=$ \strong {o}utput \strong {f}eed\strong {b}ack.
	\end   {itemize}

	Only ``ecb'' neither requires a shift value nor an initialization
	vector (see options below). All other (``stream'') modes require
	the initialization vector, the feedback modes additionally
	need a shift value.

	The number of characters buffered internally depends both on
	cipher and operation mode.
	In 'ebc'- and 'cbc'-modes blocksize-1 characters are buffered.
	The feedback modes buffer shift-1 characters.


\item[-iv]	Argument to this option has to be a readable
		channel. The initialization vector required by the
		stream modes is defined by the contents of this
		channel. A complete block must be stored.

\item[-shift]	Only integer numbers are allowed as values to this
		option. It defines the number of bytes the feedback
		register is shifted to the left after every
		encryption. Only positive values not larger than the
		blocksize are allowed. They must be a divisor of the
		blocksize too!
\end   {itemize}


Cipher characteristics:

\begin {center}
	\begin {tabular}{|l|l|l|}\hline
	Name		& Blocksize (in byte)	& Keysize (in byte) \\ \hline\hline
	DES		& 8			& 8 (without MSB!) \\ \hline
	IDEA		& 8			& 16 \\ \hline
	Blowfish	& 8			& 1 - 56 \\ \hline
	RC2		& 8			& 1 - 1024 \\ \hline\hline
	RC4		& -			& 1 - 256 \\ \hline
	\end   {tabular}
\end   {center}

The upper limit set upon the keysize of RC2 is artificially imposed,
due to the implementation of reading the key in the framework.


\section {Message digests}

10 message digests are implemented:

\begin {enumerate}
\item	2 crc checkers, taken from \PGP{} and library \zlib, under
	the names \cmd {crc} and \cmd {crc-zlib} resp.
\item	The adler-checksum, taken from \zlib{} too.
\item	MD2, MD5
\item	SHA (or SHS), SHA-1
\item	HAVAL
\item	\rmd, -128
\end   {enumerate}

The commands to invoke them are identical to the names, converted to
all lowercase. In immediate mode no options are allowed. Attached
digests have two submodes available:

\begin {itemize}
\item[-mode]	The allowed arguments are ``absorb'', ``write'' and
		all unique abbreviations.

		In the first submode written data is not changed
		except for attachment of the message digest at the
		end of the input. During reading a digest is computed
		too and then compared to the one attached. The
		'-matchflag' must be defined to propagate the result
		of the comparison to the tcl-level (``ok'' or ``failed'').

		In the second submode read or written data goes into
		nirwana, their digests are computed as
		side effect. After the channel is closed the computed
		digests are written to the channels specified with
		'-read/write-dest'.

\item[-matchflag]	The value specifies the name of global
			variable to write the result of a digest
			comparison into. Allowed for mode ``absorb''
			only. Its definition for a write-only channel
			will be ignored.

\item[-write-dest]	The value must specify a writable channel. The
			message digest computed for data written to
			the attached channel is written into it after
			closing the attached channel. Allowed for mode
			``write'' only. Its definition for a readonly
			channel is ignored.

\item[-read-dest]	The value must specify a writable channel. The
			message digest computed for data read from
			the attached channel is written into it after
			closing the attached channel. Allowed for mode
			``write'' only. Its definition for a write-only
			channel is ignored.
\end   {itemize}


\section {Data conversion}

All data conversion commands support only one option,
``-mode''. Allowed values are ``encode'', ``decode'' and all unique
abbreviations. It specifies the operation to be executed in immediate
mode or the operation executed upon \strong {write} if attached to a
channel.

Encode converts from binary data into the described representation,
decode does the reverse (obviously :-).

Standard conversions are
\begin {itemize}
\item[bin]	Converts bytes into dual representation.
\item[oct]	Converts bytes into octal representation.
\item[hex]	Converts bytes into hexadecimal representation.
\end   {itemize}
None of them buffers characters internally.

\begin {itemize}
\item[uuencode]	Blocks of 3 characters are uuencoded/decoded. Will
		buffer 2 characters internally until a block is complete.
\item[base64]	Blocks of 3 characters are
		base64-encoded/decoded. This is equivalent to \PGP{}'s
		ASCII armor. Used by MIME too. Will buffer 2
		characters internally until a block is complete.
\item[ascii85]	Blocks of 4 characters will be encoded into Ascii85
		representation as defined in the 'Postscript Reference
		Manual' (2nd Edition, section 3.13, page 129).
\end   {itemize}
All of these are able to convert an incomplete block at the end of
input.

\section {Misc.}

4 other commands are available, not fitting into the categories above:

\begin	{enumerate}
\item	A reed-solomon error correcting coder is available under the
	name \cmd {rs\_ecc}. The one and only option understood is
	``-mode''. It is equivalent to the option understood by the
	conversion commands in the last section. The coder operates on
	blocks of 248 characters each, therefore buffering 247
	characters.

\item	A compressor based upon the \zlib{}-library. It is
	available under the name \cmd {zip} and understands the
	following options:

	\begin	{itemize}
	\item[-mode]	Allowed arguments are ``compress'',
			``'decompress' and all unique abbreviations of
			these.
	\item[-level]	Possible arguments are ``default'' and integer
			numbers in the range 1 \dots{} 9. It specifies
			the used compression level.
	\end	{itemize}

\item	\cmd {unstack}. This command must be used to remove a
	conversion channel. The underlying channel is uncovered and
	accessible again afterward. It requires a channelhandle as its
	one and only argument. Its application to a normal channel
	(file, socket, \dots {}) is identical to \cmd {close}.

\item	\cmd {binio}. See file \file {doc/binio.proposal}
	for more information. This command is excluded by default, as
	tcl 8.0b1 now provides equivalent functionality (See commands
	\cmd {binary} and \cmd {fcopy}). Inclusion requires
	application of the byteorder patch. See the \installman{} for
	more information.
\end	{enumerate}


\section {Quick Reference}
Now a quick reference describing the available commands, their type of
algorithm and location of implementation. The format specifiers
available to \cmd {binio} can be found in a separate table afterward.

\begin {tabular}{|l|l|l|}\hline
	Command		& Type				& Location \\ \hline\hline
	adler		& Message digest		& \zlib	\\ \hline
	ascii85		& Conversion			& \trf	\\ \hline
	base64		& Conversion			& \trf	\\ \hline
	bin		& Conversion			& \trf	\\ \hline
	binio		& Binary I/O			& \trf	\\ \hline
	blowfish	& Blockcipher			& \trf	\\ \hline
	crc		& Message digest		& \trf	\\ \hline
	crc-zlib	& Message digest		& \zlib	\\ \hline
	des		& Blockcipher			& \SSLeay \\ \hline
	haval		& Message digest		& \trf	\\ \hline
	hex		& Conversion			& \trf	\\ \hline
	idea		& Blockcipher			& \trf	\\ \hline
	md2		& Message digest		& \SSLeay \\ \hline
	md5		& Message digest		& \trf	\\ \hline
	oct		& Conversion			& \trf	\\ \hline
	rc2		& Blockcipher			& \SSLeay \\ \hline
	rc4		& Cipher			& \trf	\\ \hline
	ripemd160	& Message digest		& \trf	\\ \hline
	ripemd128	& Message digest		& \trf	\\ \hline
	rs\_ecc		& Error correcting coder	& \trf	\\ \hline
	sha		& Message digest		& \trf	\\ \hline
	sha1		& Message digest		& \SSLeay \\ \hline
	unstack		&				& \trf	\\ \hline
	uuencode	& Conversion			& \trf	\\ \hline
	zip		& Data compression		& \zlib	\\ \hline
\end {tabular}

This is more than a table of the format specifiers available to
\cmd{binio}. It includes a comparison to \cmd{binary format} of tcl
8.0b1 too.

\begin {tabular}{|l|l|l|}\hline
Format & Meaning		& Meaning in 8.0b1 \\ \hline\hline
a & --				& string, '\strterm'-padded		\\ \hline
A & --				& string, space-padded			\\ \hline
b & --				& binary digits, low-2-high		\\ \hline
B & --				& binary digits, high-2-low		\\ \hline
c & signed int, 8 bit (char)	& see left				\\ \hline
C & unsigned int, 8 bit		& --					\\ \hline
d & signed int, 32 bit		& floating number, 64 bit		\\ \hline
D & signed int, 16 bit		& --					\\ \hline
f & floating number, 32 bit	& see left.				\\ \hline
F & floating number, 64 bit	& --					\\ \hline
h & --				& hex digits, low-2-high		\\ \hline
H & --				& hex digits, high-2-low		\\ \hline
i & --				& signed int, 32 bit, little endian	\\ \hline
I & --				& signed int, 32 bit, big-endian	\\ \hline
l & signed int, 64 bit		& --					\\ \hline
L & unsigned int, 64 bit	& --					\\ \hline
o & signed int, 32 bit, octal	& --					\\ \hline
O & signed int, 16 bit, octal	& --					\\ \hline
s & string, '\strterm'-terminated & signed int, 16 bit, little-endian	\\ \hline
S & --				& signed int, 16 bit, big-endian	\\ \hline
u & unsigned int, 32 bit	& --					\\ \hline
U & unsigned int, 32 bit	& --					\\ \hline
x & signed int, 32 bit, hex	& '\strterm'				\\ \hline
X & signed int, 16 bit, hex	& Set cursor relative			\\ \hline
@ & --				& Set cursor absolute			\\ \hline
\end {tabular}

There is a more subtle difference too. In contrast to \cmd {binio},
which uses the channel byteorder to determine the endianness of the
written data \cmd{binary format} requires an explicit specification. In
general \cmd{binary format} is much nearer to the perl equivalent
((un)pack), despite the names.



\chapter {Copyrights}\label {copyright}

Copyright notes and acknowledgements for the different ciphers,
message digests, \dots {}:

\begin {enumerate}
\item	MD5 is copyright '\rsadsi{}'. The note at the
	beginning of \file {md5.h} says:

	\begin {quotation}
		License to copy and use this software is granted
		provided that it is identified as the "\rsadsi{} MD5
		Message-Digest Algorithm" in all material mentioning
		or referencing this software or this function.
                                                                  
		License is also granted to make and use derivative
		works provided that such works are identified as
		"derived from the \rsadsi{} MD5 Message-Digest
		Algorithm" in all material mentioning or referencing
		the derived work.
	\end   {quotation}

	I consider the terms of the license fulfilled by this
	quotation. 

\item	HAVAL is copyright $C^3SR$ and may not be sold or used as
	inducement to buy a product without the written permission of
	$C^3SR$. For technical questions or questions regarding the
	code used here contact the author of HAVAL (and code): \yuliang.

	I made some minor changes to eliminate masses of \cmd
	{gcc}-warnings regarding operator priority in expressions, but
	did not change the semantics.


\item	SHA / SHS was specified by the US government agency
	\NIST. Primary author of the code used here seems to be
	\pgutmann, with heavily modifications from \uh. 

\item	The implementation of DES (libdes) used here is copyrighted by
	\eay.

\item	IDEA (International Data Encryption Algorithm) is a block
	cipher developed  by  Dr. Xuejia Lai  and \massey{} at the \sfit{}.

	The implementation used here was written by \demoliner.

	\strong {Warning}:
	\begin {quotation}
		The IDEA(tm) block cipher is covered by a patent held
		by ETH and a Swiss company called \ascom{}.  The
		Swiss patent number is PCT/CH91/00117.  International
		patents are pending. IDEA(tm) is a trademark of
		\ascom{}.  \strong {There is no license fee required for
		noncommercial use}.  Commercial users may obtain
		licensing details from Dieter Profos, \ascom{},
		Solothurn Lab, Postfach 151, 4502 Solothurn,
		Switzerland, Tel +41 65 242885, Fax +41 65 235761. 
	\end {quotation}

\item	Blowfish was invented by \schneier{} and is decribed in the
	2nd edition of his book ``Applied Cryptography''. His sources
	were used, with small modifications to interface it with this
	package.

	The statement of the author about the legal state of the
	algorithm:

	\begin {quotation}
		Blowfish is unpatented, and will remain so in all
		countries. The algorithm is hereby placed in the
		public domain, and can be freely used by anyone.
	\end {quotation}

\item	RC4 was invented by \rsadsi{} and considered a ``Trade
	Secret''. Somewhere in this big world it was reengineered and
	the result made public, rendering the secret useless.

	I don't know that \rsadsi will try to inflict on people using
	it in the USA. Use it at your own risk.

\item	The Reed-Solomon error correcting coder is copyrighted by
	\paulf{} under the terms of the GNU General Public License.

\item	The library \zlib{} ((de)compression) is copyrighted by
	\jlgailly{} and \madler.

\item	\rmd{} is copyright \dobbertin{}, \bosselaers{} and \preneel{}.
\end   {enumerate}


\chapter {Future}

Things to be done in future.

\begin {itemize}
\item	The tests are incomplete, expand them.
\item	Add more ciphers (\PGP!). Take a look at \pgplib{} by \tage{}.
\item	Transparent mode for digests.
\item	Channel doing special framing after a fixed (user-defined)
	number of characters
\item	Random-byte generator (as real channeltype, no transformation!)
\item	Identity-transformation with ability to gather statistics
	about the information flowing through it.
\item	Anybody out there wishing more ? Feel free to send \me{}
	suggestions.
\end   {itemize}


\printindex
\end {document}
