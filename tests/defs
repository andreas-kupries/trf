# -*- tcl -*-
# This file contains support code for the TRF test suite.  It is
# normally sourced by the individual files in the test suite before
# they run their tests.  This improved approach to testing was designed
# and initially implemented by Mary Ann May-Pumphrey of Sun Microsystems.
#
# Copyright (c) 1990-1994 The Regents of the University of California.
# Copyright (c) 1994 Sun Microsystems, Inc.
#
# Modified      1995 Andreas Kupries (a.kupries@westend.com)
# Modified      1997 Andreas Kupries (a.kupries@westend.com)
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# CVS: $Id$

if {[info tclversion] < 8.0} {
    package require -exact Memchan 1.2
} else {
    package require Memchan
}

if ![info exists VERBOSE] {
    set VERBOSE 0
}
if ![info exists TESTS] {
    set TESTS {}
}

# If tests are being run as root, issue a warning message and set a
# variable to prevent some tests from running at all.

set user {}
catch {set user [exec whoami]}
if {$user == "root"} {
    puts stdout "Warning: you're executing as root.  I'll have to"
    puts stdout "skip some of the tests, since they'll fail as root."
}

# Some of the tests don't work on some system configurations due to
# differences in word length, file system configuration, etc.  In order
# to prevent false alarms, these tests are generally only run in the
# master development directory for Tcl.  The presence of a file
# "doAllTests" in this directory is used to indicate that the non-portable
# tests should be run.

set doNonPortableTests [file exists doAllTests]

proc print_verbose {test_name test_description contents_of_test code answer} {
    puts stdout "\n"
    puts stdout "==== $test_name $test_description"
    puts stdout "==== Contents of test case:"
    puts stdout "$contents_of_test"
    if {$code != 0} {
	if {$code == 1} {
	    puts stdout "==== Test generated error:"
	    puts stdout $answer
	} elseif {$code == 2} {
	    puts stdout "==== Test generated return exception;  result was:"
	    puts stdout $answer
	} elseif {$code == 3} {
	    puts stdout "==== Test generated break exception"
	} elseif {$code == 4} {
	    puts stdout "==== Test generated continue exception"
	} else {
	    puts stdout "==== Test generated exception $code;  message was:"
	    puts stdout $answer
	}
    } else {
	puts stdout "==== Result was:"
	puts stdout "$answer"
    }
}

proc test {test_name test_description contents_of_test passing_results} {
    global VERBOSE
    global TESTS
    if {[string compare $TESTS ""] != 0} then {
	set ok 0
	foreach test $TESTS {
	    if [string match $test $test_name] then {
		set ok 1
		break
	    }
        }
	if !$ok then return
    }
    set code [catch {uplevel $contents_of_test} answer]
#
#    memory active $test_name
#
    if {$code != 0} {
	print_verbose $test_name $test_description $contents_of_test \
		$code $answer
    } elseif {[string compare $answer $passing_results] == 0} then { 
	if $VERBOSE then {
	    print_verbose $test_name $test_description $contents_of_test \
		    $code $answer
	    puts stdout "++++ $test_name PASSED"
	}
    } else {
	print_verbose $test_name $test_description $contents_of_test $code \
		$answer 
	puts stdout "---- Result should have been:"
	puts stdout "$passing_results"
	puts stdout "---- $test_name FAILED" 
    }
}

proc dotests {file args} {
    global TESTS
    set savedTests $TESTS
    set TESTS $args
    source $file
    set TESTS $savedTests
}


# -- attention procs --

# utilities for easy specification and use of constant values (hex)

proc defblock {name hexdata} {
    upvar $name x

    regsub -all { *} $hexdata {} hexdata
    regsub -all "\n" $hexdata {} hexdata
    # single long hex string now

    set x $hexdata
}


proc hex2chan {hexdata} {
    set               x [memchan]
    fconfigure       $x -translation binary
    hex  -attach     $x -mode decode
    puts -nonewline  $x $hexdata
    unstack          $x
    seek             $x 0
    return           $x
}


proc text2hex {data} {
    set               x [memchan]
    fconfigure       $x -translation binary
    hex  -attach     $x -mode encode
    puts -nonewline  $x $data
    unstack	     $x
    seek             $x 0
    set data   [read $x]
    close            $x

    return           $data
}


proc text2chan {data} {
    set               x [memchan]
    fconfigure       $x -translation binary
    puts -nonewline  $x $data
    seek             $x 0
    return           $x
}

if {[info tclversion] < 8.0} {
    proc exec_cipher {bc key iv in bc_args} {
	set _key [hex2chan $key]
	set _in  [hex2chan $in]
	if {$iv != {}} {set _iv [hex2chan $iv]}

	set has_out 0
	set text ""

	regsub -all {@key} $bc_args $_key bc_args
	regsub -all {@in}  $bc_args "-in $_in"  bc_args

	if {$iv != {}} {regsub -all {@iv} $bc_args $_iv bc_args}

	if {[regexp -- {@out} $bc_args]} {
	    set _out [memchan]
	    hex -attach $_out -mode encode
	    regsub -all {@out}  $bc_args "-out $_out" bc_args
	    
	    set has_out 1
	}

	#puts "<<$bc $bc_args -key-type channel>>"

	if {$iv == {}} {
	    eval $bc $bc_args -key-type channel
	} else {
	    eval $bc $bc_args -key-type channel -iv-type channel
	}

	close $_key
	close $_in
	if {$iv != {}} {close $_iv}

	if {$has_out} {
	    unstack $_out
	    seek $_out 0
	    set text [read $_out]
	    close $_out
	}

	return $text
    }


    proc exec_md {md hexinput} {
	set              in [memchan]
	hex -attach     $in -m d
	puts -nonewline $in $hexinput
	unstack         $in
	seek            $in 0

	set       out [memchan]
	hex -attach $out -m e 

	$md -in $in -out $out

	close   $in
	unstack          $out
	seek             $out 0

	set res [read -nonewline $out]
	close $out
	set res
    }

} else {
    proc exec_cipher {bc key iv in bc_args} {
	error "don't use exec_cipher with tcl 8.x and higher"
    }

    proc exec_md {md hexinput} {
	error "don't use exec_md with tcl 8.x and higher"
    }
}


proc xx_cmp {a b blocksize} {
    set bsi [expr {$blocksize - 1}]

    while {([string length $a] > 0) || ([string length $b] > 0)} {
	set af [string range $a 0 $bsi]
	set bf [string range $b 0 $bsi]

	set a [string range $a $blocksize end]
	set b [string range $b $blocksize end]

	if {0 != [string compare $af $bf]} {
	    puts -nonewline stdout "* "
	} else {
	    puts -nonewline stdout "  "
	}

	puts stdout "$af  $bf"
    }
}


proc string_rep {n text} {
    # @comment Replicates <a n> times the string <a text>.
    # @argument text: string to be replicated
    # @argument n:    number of replications
    # @result <a text> replicated <a n> times

    # no replication required ?
    if {$n <= 0} {return ""}

    # use iteration to build up the result
    set result ""
    for {} {$n > 0} {incr n -1} {append result $text}

    return $result
}
